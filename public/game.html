<!doctype html> 
<html lang="en"> 
<head> 
	<meta charset="UTF-8" />
	<title>Multiplayer game</title>
	
		<!-- Bootstrap core CSS -->
    <link href="./dist/css/bootstrap.min.css" rel="stylesheet">
    
    <script src="//cdn.jsdelivr.net/phaser/2.2.2/phaser.min.js"></script>
    
</head>
<body>
<button type="button" class="btn btn-default" id="fullscreen">Full screen</button>
<div class="modal fade" tabindex="-1" id="usernameModal" role="dialog">
  <div class="modal-dialog" role="document">
    <div class="modal-content">
      <div class="modal-header">
        <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
        <h4 class="modal-title">Multiplayer game</h4>
      </div>
      <div class="modal-body">
        <p>Submit a playername before playing. Use arrow keys to control on keyboard, or touch the screen on a phone.</p>
        <p> You will have to work together to reach higher platforms. </p>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-default" data-dismiss="modal">Close</button>
      </div>
    </div><!-- /.modal-content -->
  </div><!-- /.modal-dialog -->
</div><!-- /.modal -->

<script src="./dist/jquery.min.js"></script>
<script src="/socket.io/socket.io.js"></script>
<script src="./dist/js/bootstrap.min.js"></script>

<script type="text/javascript">

//Create a game
var game = new Phaser.Game(800, 600, Phaser.AUTO, 'game', { preload: preload, create: create, update: update, preRender: preRender });

//Loading in the images and sprites for use in create() and update().
function preload() {
	game.stage.disableVisibilityChange = true;
	game.load.image('sky', 'assets/background.png');
	game.load.image('ground','assets/platform.png');
	game.load.image('star','assets/star.png');
	game.load.spritesheet('dude','assets/dude.png',32,48);
	game.load.image('cloud-platform', 'assets/cloud-platform.png');
	
}

//Variables
var platforms; //the group for the platforms
var background; //used to move the background as the player climbs higher
var cursors; //takes the user keyboard inputs
var player; //the local player
var otherplayers = new Object(); //otherplayers[id] should point to the player sprite object
var stars; //the stars
var clouds; //the group for cloud platforms
var cloud1;
var score = 0; //score for the scoreboard
var scoreText; //used to print the score to the screen
var playergroup; //contains all players
var wasLocked = false;
var lockedTo = null;
var locked = false; //Used to check if the local player is on a cloud
var willJump = false;
var jumpTimer = 0;
/*
	the objectPositions array will store all the initial positions
	of objects from the server.
	this is used to place the cloud platforms and other moving objects into their
	current position.
	
	objectPositions = 
		{
			(cloud1) 1: {posx, posy}	
		}
*/
var objectPositions = new Object();
var timeServerStarted;
objectPositions[1] = {posx: 450, posy: 800};

//Websocket varaibles
var socket = io();
var players = new Object();
var socketID;


/*
	Sending initial data to server
*/
socket.emit('objects position', JSON.stringify(objectPositions) );

/* 
	dealing with the websocket data from the server:
*/
socket.on('ID', function(id) {

	socketID = id;
	console.log('socketID: ' +socketID);

});
socket.on('players', function(data) {

	//data comes in as a JSON string:
	players = $.parseJSON(data);

});
//Listen for players jumping
socket.on('jump', function(id) {

	//player 'id' jumped
	otherplayers[id].body.velocity.y = -250;

});
//Listen for players leveling up (changes sprite depending on lvl)
socket.on('level up', function(id) {

	//player 'id' has leveled up

});
//Listen for the time at which the server started
//this allows us to move objects to where they should
//be
socket.on('time at start', function(time) {

	timeServerStarted = Math.round(time); //Math.round does the string to int conversion
	console.log(timeServerStarted);
	


	

});
//Show game info to user:
//$('#usernameModal').modal('show');

//button clicked to go into full screen:
$('#fullscreen').click(function () {
	console.log('#cluick');
	game.scale.startFullScreen(false);

});

/*
	Initially called to create game objects
*/
function create() {
	
	//Setup the game world:
	game.world.setBounds(0,0,800,1200);
	
	//enable the physics system
	game.physics.startSystem(Phaser.Physics.ARCADE);
	
	// A simple background
	background = game.add.sprite(0,  0, 'sky');
	
	
	//The platforms group contains the groupand the 2 ledges we can jump on
	platforms = game.add.group();
	
	//enable physics for any object that is created in this group
	platforms.enableBody = true;
	
	//Create the ground
	var ground = platforms.create(0, game.world.height - 64, 'ground');
	
	//scale it to fit the width of the game
	ground.scale.setTo(2,2);

	//ground immovable
	ground.body.immovable = true;
	
	//Create two ledges
	var ledge = platforms.create(400,game.world.height-200, 'ground');
	
	ledge.body.immovable = true;
	
	ledge = platforms.create(-150, game.world.height - 350, 'ground');

	ledge.body.immovable = true;
	
	//The player group 
	playergroup = game.add.group(); 
	playergroup.enableBody = true;
	
	//create the local player:
	player = game.add.sprite(32, game.world.height - 150, 'dude');
	
	//Enable physics on the player
	game.physics.arcade.enable(player);
	
	//player physics properties
	player.body.bounce.y = 0.2;
	player.body.gravity.y = 300;
	player.body.collideWorldBounds = true;
	
	// our two animations, walking left and right:
	player.animations.add('left', [0,1,2,3], 10, true);
	player.animations.add('right', [5,6,7,8], 10, true);
	
	//Camera follow player
	game.camera.follow(player, Phaser.Camera.FOLLOW_TOPDOWN);
	
	//add player to the playergroup
	playergroup.add(player);
	
	//Add the stars:
	stars = game.add.group();
	stars.enableBody = true;
	
	//Create 12 stars evenly space apart
	for (var i=0; i<12; i++) {
		// Create a star inside the star group
		var star = stars.create(i*70,0, 'star');
		
		//Let gravity work
		star.body.gravity.y = 6;
		
		//A random amount of bounce
		star.body.bounce.y = 0.7 + Math.random() * 0.2;
	}
	
	//Add all the other players from the websocket:
	for(var id in players) {
		if (id == socketID) {
			//do nothing, this is our player
		}
		else {
			//Add this player, it is an online user
			otherplayers[id] = game.add.sprite(players[id].posx, players[id].posy,'dude');
	
			//Enable physics on this player
			game.physics.arcade.enable(otherplayers[id]);
		
			//player physics properties
			otherplayers[id].body.bounce.y = 0.2;
			otherplayers[id].body.gravity.y = 600;
			otherplayers[id].body.collideWorldBounds = true;
		
			// our two animations, walking left and right:
			otherplayers[id].animations.add('left', [0,1,2,3], 10, true);
			otherplayers[id].animations.add('right', [5,6,7,8], 10, true);
			
			//Add to playergroup
			playergroup.add(otherplayers[id]);
		}
	}
	
	
	//Create the cloud platforms:
	clouds = game.add.physicsGroup();
	
	createObjects(); //creates all the objects e.g. cloud platforms
	
	scoreText = game.add.text(16,16, 'score: 0', {fontSize: '32px', fill: '#000' });
	scoreText.fixedToCamera = true;
	
	//Keyboard input
	cursors = game.input.keyboard.createCursorKeys();
	
	//mouse or touch input:
	pointer = game.input.addPointer();
	
	//Allow full screen
	game.scale.fullScreenScaleMode = Phaser.ScaleManager.SHOW_ALL;
	
}


/*
	The preRender method is called after all Game Objects have been updated, 
	but before any rendering takes place.
*/
function preRender() {

	if (locked || wasLocked) {
		player.position.x += lockedTo.deltaX;
		player.position.y = lockedTo.y - 48;
		
		if (player.body.velocity.x !== 0) {
			player.body.velocity.y = 0;
		}
	}
	
	if (willJump) {
	
		willJump = false;
		
		if (lockedTo && lockedTo.deltaY < 0 && wasLocked) {
			//if the platform is moving up we add its velocity to the player's jump
			player.body.velocity.y = -200 + (lockedTo.deltaY * 10);
		
		}
		else {
		
			player.body.velocity.y = -200;
		
		}
		
		jumpTimer = game.time.time + 750;
	
	}
	
	if (wasLocked) {
	
		wasLocked = false;
		lockedTo.playerLocked = false;
		lockedTo = null;
	
	}

}

/*
	This function is called to update the game automatically
*/
function update() {


	//collide the player and the stars with the platforms
	game.physics.arcade.collide(playergroup, platforms);
	game.physics.arcade.collide(player, clouds, customSep, null, this);
	game.physics.arcade.collide(playergroup, playergroup);
	game.physics.arcade.collide(stars, platforms);
	game.physics.arcade.overlap(player, stars, collectStar, null, this);
	
	//Check if the player is standing. This is used when testing
	//if the player can jump later.
	var standing = player.body.blocked.down || player.body.touching.down || locked;
	
	//Reset the players velocity
	player.body.velocity.x = 0;
	
	//Makes it easier to refer to the players touch pointer
	var pointer = game.input.pointer1;
	
	if (cursors.left.isDown || (pointer.active && pointer.worldX < 400)) {
	
		//Move to the left:
		player.body.velocity.x = -150;
		player.animations.play('left');
		
	
	} else if (cursors.right.isDown || (pointer.active && pointer.worldX > 400)) {
	
		//move to the right
		player.body.velocity.x = 150;
		player.animations.play('right');
	
	} else {
	
		//stand still
		player.animations.stop();
		player.frame = 4;
	
	} 
	
	if ((cursors.up.isDown || (pointer.active && (pointer.worldY < (player.body.position.y-200))) ) && standing && game.time.time > jumpTimer ) {
		if (locked) {
			
			cancelLock();
		
		}

		willJump = true;
		
		//player.body.velocity.y = -550;
		
		//socket.emit('jump','jump');
	
	}
	
	if (locked) {
	
		checkLock();
	
	}
	
	//Loop through the other players:
	for (var id in players) {
		
		//If the id matches the socketID then this is the current user's player so we remove
		// the double sprite.
		if(id == socketID) {
			if( typeof otherplayers[id] === 'undefined' || otherplayers[id] === null) {
				//Do nothing
			}
			else {
				//Remove the second sprite for the player
				console.log('killing the repeated sprite');		
				otherplayers[id].kill();
			}
		}
		else if( typeof players[id] !== 'undefined') {
			//Check if this player has been created already
			if (typeof otherplayers[id] !== 'undefined') {
			
				//Update this player on the screen
				updatePlayerAttributes(otherplayers[id], players[id]);
				
			} 
			//If this player hasn't been added, we add it now
			else{

				otherplayers[id] = game.add.sprite(32, game.world.height - 150,'dude');
	
				//Enable physics on this player
				game.physics.arcade.enable(otherplayers[id]);
		
				//player physics properties
				otherplayers[id].body.bounce.y = 0.2;
				otherplayers[id].body.gravity.y = 300;
				otherplayers[id].body.collideWorldBounds = true;
		
				// our two animations, walking left and right:
				otherplayers[id].animations.add('left', [0,1,2,3], 10, true);
				otherplayers[id].animations.add('right', [5,6,7,8], 10, true);
				
				//Add to playergroup
				playergroup.add(otherplayers[id]);
				
			}
		}
	}
	//Remove all disconnected players:
	for (var id in otherplayers) {
	
		if (typeof players[id] === 'undefined') {
			playergroup.remove(otherplayers[id]);
			otherplayers[id].kill();
		}
	
	}
	
	//Update the position of cloud1
	updateCloud1(Date.now());

	socket.emit('player position', JSON.stringify({posx: player.body.position.x, posy: player.body.position.y, velx: player.body.velocity.x, vely: player.body.velocity.y}));

}

//Called when a player collects a star
function collectStar( player, star) {

	//Remove the star
	star.kill();
	
	//Add and update the score
	score += 1;
	scoreText.text = 'score: '+score;
	
	socket.emit('level up', score);

}

/*
	Checks if the player should be unlocked
	from the cloud platform
*/
function checkLock() {
	player.body.velocity.y = 0;
	
	//If the player has walked off either side then they 
	//are no longer locked to it
	if (player.body.right < lockedTo.body.x || player.body.x > lockedTo.body.right) {
	
		cancelLock();
	
	}
}

/*
	Cancels the lock which the player has
	with the cloud platform
*/
function cancelLock() {

	wasLocked = true;
	locked = false;

}

/*
	This function updates a players animation and position:
	To reduce the jitteryness, we adjust the speed to have the player
	catch up to where it should be.
*/
function updatePlayerAttributes(player, data) {

	game.physics.arcade.collide(player, platforms);
	
	//Reset the players velocity
	player.body.velocity.x = data.velx;
	player.body.velocity.y = data.vely;
	player.body.position.x = data.posx;
	player.body.position.y = data.posy;
	
	if (data.velx < 0) {
	
		player.animations.play('left');
	
	} else if (data.velx > 0) {
	
		player.animations.play('right');
	
	} else {
	
		//stand still and slide to correct location
		player.animations.stop();
		player.frame = 4;
	
	} 
}

/*
	The collision callback handler for the clouds:

*/
function customSep(player, platform) {
	
	//If the player is in a jump and falling down and not
	//already locked to the platform then we tell
	//the game the player is now locked.
	if (!locked && player.body.velocity.y > 0) {
	
		//the platform landed on is stored in lockedTo
		locked = true;
		lockedTo = platform;
		platform.playerLocked = true;
		
		//Velocity reset
		player.body.velocity.y = 0;
	
	}

}

/*
	This function updates the positioin of cloud1
	the cloud moves in 4 stages: 
		0: 	right-up
		1:	left-up
		2:	left-down
		3:	right-down
*/
function updateCloud1(time) {
	stage = Math.floor(((time - timeServerStarted) % 8000) / 2000);

game.world.height - 500
	switch (stage) {
		
		case 0:
			//Right and up
			cloud1.body.position.x = 450 + (( (time - timeServerStarted) % 2000 ) * 0.1);
			cloud1.body.position.y = game.world.height - 400 - (( (time - timeServerStarted) % 2000 ) * 0.05);
			break;
		case 1:
			//left and up
			cloud1.body.position.x = 650 + (( (time - timeServerStarted) % 2000 ) * (-0.1));
			cloud1.body.position.y = game.world.height - 500 - (( (time - timeServerStarted) % 2000 ) * 0.05);
			break;
		case 2:
			//left and down
			cloud1.body.position.x = 450 + (( (time - timeServerStarted) % 2000 ) * (-0.1));
			cloud1.body.position.y = game.world.height - 600 - (( (time - timeServerStarted) % 2000 ) * (-0.05));
			break;
		case 3:
			//right and down
			cloud1.body.position.x = 250 + (( (time - timeServerStarted) % 2000 ) * 0.1);
			cloud1.body.position.y = game.world.height - 500 - (( (time - timeServerStarted) % 2000 ) * (-0.05));
			break;
	}
}

/*
	Creates all the objects useing the timeFromServer
	to compute where each object should be.
*/
function createObjects() {

	//Create a cloud, and add it to the group of clouds
	console.log(objectPositions[1].posx);
	cloud1 = new CloudPlatform(game, objectPositions[1].posx, objectPositions[1].posy, 'cloud-platform', clouds); //450, 800
	

}
	
/*
	The constructor for the cloud platforms.
Followed by the functions to control motion.
*/
CloudPlatform = function (game, x, y, key, group) {

	if (typeof group === 'undefined') { group = game.world; }

    Phaser.Sprite.call(this, game, x, y, key);

    game.physics.arcade.enable(this);

    this.anchor.x = 0.5;

    this.body.customSeparateX = true;
    this.body.customSeparateY = true;
    this.body.allowGravity = false;
    this.body.immovable = true;

    this.playerLocked = false;

    group.add(this);

};

CloudPlatform.prototype = Object.create(Phaser.Sprite.prototype);
CloudPlatform.prototype.constructor = CloudPlatform;


</script>



</body>
</html>
